{
open Syntax
open Parser
open System.Text
open FsLexYaccLite.Lexing

let newline (lexbuf:LexBuffer) = lexbuf.EndPos <- lexbuf.EndPos.NextLine


let unexpected_char (lexbuf : LexBuffer) =
  failwith ("Unexpected character '"+(lexbuf.Lexeme)+"'")

let typeDepth = ref 0
let startPos = ref Position_Empty
let mutable str_buf = new System.Text.StringBuilder()

let appendBuf (str:string) = str_buf.Append str |> ignore
let clearBuf () = str_buf <- new System.Text.StringBuilder()

} 

let letter = ['A'-'Z'] | ['a'-'z']
let digit = ['0'-'9']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')
let ident_start_char = letter       
let ident_char = ( ident_start_char| digit | ['\'' '_'] )
let ident = ident_start_char ident_char*

rule token = parse
 | "%{" { let p = lexbuf.StartPos in header p (new StringBuilder 100) lexbuf }
 | "%%" { PERCENT_PERCENT }
 | "%token" (whitespace* '<') { typeDepth := 1; startPos := lexbuf.StartPos; clearBuf(); TOKEN (fs_type lexbuf) }
 | "%token" { TOKEN (None) }
 | "%start"{ START }
 | "%prec"{ PREC }
 | "%type" (whitespace* '<') { typeDepth := 1; startPos := lexbuf.StartPos; clearBuf(); TYPE (match fs_type lexbuf with Some x -> x | None -> failwith "gettype") }
 | "%left" { LEFT }
 | "%right" { RIGHT }
 | "%nonassoc" { NONASSOC }
 | ';' { SEMI }
 | '{' { let p = lexbuf.StartPos in 
         let buff = (new StringBuilder 100) in
         // adjust the first line to get even indentation for all lines w.r.t. the left hand margin
         buff.Append (String.replicate (lexbuf.StartPos.Column+1) " ")  |> ignore;
         code p buff lexbuf }
 | whitespace+  { token lexbuf }
 | newline { newline lexbuf; token lexbuf }
 | ident_start_char ident_char* { IDENT lexbuf.Lexeme }
 | '|' { BAR }
 | "/*" { ignore(comment lexbuf); token lexbuf }
 | "//" [^'\n''\r']* {  token lexbuf  }
 | ':' { COLON }
 | _ { unexpected_char lexbuf }     
 | eof { EOF  }  

and fs_type = parse
  | '<' { incr typeDepth; appendBuf(lexbuf.Lexeme); fs_type lexbuf}
  | '>'
    { decr typeDepth; 
      if !typeDepth = 0
      then Some(string str_buf) 
      else appendBuf(lexbuf.Lexeme); fs_type lexbuf }
  | _ { appendBuf(lexbuf.Lexeme); fs_type lexbuf } 
                                   
and header p buff = parse
 | "%}" { HEADER (buff.ToString()) }
 | newline { newline lexbuf; 
             ignore <| buff.Append System.Environment.NewLine; 
             header p buff lexbuf }
 | (whitespace | letter | digit) +  
      { ignore <| buff.Append (lexbuf.Lexeme); 
        header p buff lexbuf }
 | "//" [^'\n''\r']*
      { ignore <| buff.Append (lexbuf.Lexeme); 
        header p buff lexbuf }
 | "'\"'" | "'\\\"'"
      { ignore <| buff.Append (lexbuf.Lexeme); 
        header p buff lexbuf }
 | "\"" 
      { ignore <| buff.Append (lexbuf.Lexeme); 
        ignore(codestring buff lexbuf); 
        header p buff lexbuf }
 | eof { EOF }
 | _ { ignore <| buff.Append(lexbuf.Lexeme).[0]; 
       header p buff lexbuf }
and code p buff = parse
 | "}" { CODE (buff.ToString()) }
 | "{" { ignore <| buff.Append (lexbuf.Lexeme); 
         ignore(code p buff lexbuf); 
         ignore <| buff.Append "}"; 
         code p buff lexbuf }
 | newline { newline lexbuf; 
             ignore <| buff.Append System.Environment.NewLine; 
             code p buff lexbuf }
 | "'\"'" | "'\\\"'"
      { ignore <| buff.Append (lexbuf.Lexeme); 
        code p buff lexbuf }
 | "\"" { ignore <| buff.Append (lexbuf.Lexeme); 
          ignore(codestring buff lexbuf); 
          code p buff lexbuf }
 | (whitespace | letter | digit) +  
   { ignore <| buff.Append (lexbuf.Lexeme); 
     code p buff lexbuf }
 | "//" [^'\n''\r']*
   { ignore <| buff.Append (lexbuf.Lexeme); 
     code p buff lexbuf }
 | eof { EOF }
 | _ { ignore <| buff.Append(lexbuf.Lexeme).[0]; 
       code p buff lexbuf }


and codestring buff = parse
 |  '\\' ('"' | '\\')
   { ignore <| buff.Append (lexbuf.Lexeme); 
     codestring buff lexbuf } 
 | '"' { ignore <| buff.Append (lexbuf.Lexeme); 
         buff.ToString() }
 | newline { newline lexbuf; 
             ignore <| buff.Append System.Environment.NewLine; 
             codestring buff lexbuf }
 | (whitespace | letter | digit) +  
   { ignore <| buff.Append (lexbuf.Lexeme); 
     codestring buff lexbuf }
 | eof { failwith "unterminated string in code" }
 | _ { ignore <| buff.Append(lexbuf.Lexeme).[0]; 
       codestring buff lexbuf }


and comment = parse
 | "/*" { ignore(comment lexbuf); comment lexbuf }
 | newline { newline lexbuf; comment lexbuf }
 | "*/" { () }
 | eof { failwith "end of file in comment" }
 | [^ '/' '*' '\n' '\r' '"' '/' ]+  { comment lexbuf }
 | _  { comment lexbuf }

