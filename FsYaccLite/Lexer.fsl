{
open Syntax
open Parser
open System.Text
open FsLexYaccLiteRuntime

let newline (lexbuf:LexBuffer) = lexbuf.EndPos <- lexbuf.EndPos.NextLine


let unexpected_char (lexbuf : LexBuffer) =
  failwith ("Unexpected character '"+(lexbuf.Lexeme)+"'")

let typeDepth = ref 0
let startPos = ref Position_Empty
let mutable str_buf = new System.Text.StringBuilder()

let appendBuf (str:string) = str_buf.Append str |> ignore
let clearBuf () = str_buf <- new System.Text.StringBuilder()

let append (lexbuf : LexBuffer) (sb : StringBuilder) = sb.Append(lexbuf.Lexeme) |> ignore
} 

let letter = ['A'-'Z'] | ['a'-'z']
let digit = ['0'-'9']
let whitespace = [' ' '\t']
let newline = ('\n' | '\r' '\n')
let ident_start_char = letter       
let ident_char = ( ident_start_char| digit | ['\'' '_'] )
let ident = ident_start_char ident_char*

rule token = parse
 | "%{" { header (StringBuilder()) lexbuf }
 | "%%" { PERCENT_PERCENT }
 | "%token" (whitespace* '<') { typeDepth := 1; startPos := lexbuf.StartPos; clearBuf(); TOKEN (fs_type 1 (StringBuilder()) lexbuf) }
 | "%token" { TOKEN (None) }
 | "%start"{ START }
 | "%prec"{ PREC }
 | "%type" (whitespace* '<') { typeDepth := 1; startPos := lexbuf.StartPos; clearBuf(); TYPE (match fs_type 1 (StringBuilder()) lexbuf with Some x -> x | None -> failwith "gettype") }
 | "%left" { LEFT }
 | "%right" { RIGHT }
 | "%nonassoc" { NONASSOC }
 | ';' { SEMI }
 | '{' { let buf = StringBuilder()
         buf.Append(' ', lexbuf.StartPos.Column + 1) |> ignore
         code 1 buf lexbuf }
 | whitespace+  { token lexbuf }
 | newline { newline lexbuf; token lexbuf }
 | ident_start_char ident_char* { IDENT lexbuf.Lexeme }
 | '|' { BAR }
 | "/*" { ignore(comment lexbuf); token lexbuf }
 | "//" [^'\n''\r']* {  token lexbuf  }
 | ':' { COLON }
 | _ { unexpected_char lexbuf }     
 | eof { EOF  }  

and fs_type level buf = parse
  | '>' { if level = 1 then
              Some (buf.ToString()) 
          else
              append lexbuf buf
              fs_type (level - 1) buf lexbuf }
  | '<' { append lexbuf buf
          fs_type (level + 1) buf lexbuf }
  | _   { append lexbuf buf
          fs_type level buf lexbuf }
  | eof { failwith "Unterminated type expression literal" }
                                   
and header buf = parse
    | "%}"    { HEADER (buf.ToString()) }
    | newline { lexbuf.NewLine()
                append lexbuf buf
                header buf lexbuf }
    | _       { append lexbuf buf
                header buf lexbuf }
    | eof     { failwith "Unterminated header" }

and code level buf = parse
    | "}"     { if level = 1 then
                    CODE (buf.ToString())
                else
                    append lexbuf buf
                    code (level - 1) buf lexbuf }
    | "{"     { append lexbuf buf
                code (level + 1) buf lexbuf }
    | newline { lexbuf.NewLine()
                append lexbuf buf
                code level buf lexbuf }
    | _       { append lexbuf buf
                code level buf lexbuf }
    | eof     { failwith "Unterminated code" }

and comment = parse
    | "/*"                   { comment lexbuf; comment lexbuf }
    | "*/"                   { () }
    | newline                { lexbuf.NewLine(); comment lexbuf }
    | [^ '/' '*' '\r' '\n']+
    | _                      { comment lexbuf }
    | eof                    { failwith "Unterminated comment" }