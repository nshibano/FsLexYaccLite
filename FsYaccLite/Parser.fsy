%{
open Syntax
%} 

%type <Syntax.ParserSpec> spec
%token <string>  IDENT 
%token <Syntax.Code> HEADER CODE 
%token BAR PERCENT_PERCENT  START LEFT RIGHT NONASSOC LESS GREATER COLON PREC SEMI EOF ERROR
%token <string> TYPE
%token <string option> TOKEN
%start spec
%left BAR

%%      

spec: 
    | headeropt decls PERCENT_PERCENT rules EOF { { Header = $1; Decls = List.rev $2; Rules = List.rev $4 } }

headeropt: 
    | HEADER { $1 } 
    |        { "", (fst parseState.ResultRange)}

decls :
    | decls decl { $2 :: $1 }
    |            { [] }

decl :
    | TOKEN idents    { Token ($1, List.rev $2) }
    | TYPE idents     { Type ($1, List.rev $2) }
    | START idents    { Start (List.rev $2) }
    | LEFT idents     { Prec (LeftAssoc, List.rev $2) }
    | RIGHT idents    { Prec (RightAssoc, List.rev $2) }
    | NONASSOC idents { Prec (NonAssoc, List.rev $2) }

idents :
    | idents IDENT { $2 :: $1 }
    |              { [] }

rules :
    | rules rule { $2 :: $1 }
    | rule       { [$1] }

rule: IDENT COLON optbar clauses optsemi { ($1,$4) }
optbar: { } | BAR { }
optsemi: { } | SEMI { }
clauses: clause BAR clauses {$1 :: $3 } | clause { [$1] }
clause: syms optprec CODE { Rule($1,$2,Some $3) }
syms: IDENT syms { $1 :: $2 } | ERROR syms { "error" :: $2 } | { [] }
optprec: { None } | PREC IDENT { Some $2 }


