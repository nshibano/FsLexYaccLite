%{
open Syntax
%} 

%type <Syntax.ParserSpec> spec
%token <string>  IDENT 
%token <Syntax.Code> HEADER CODE 
%token BAR PERCENT_PERCENT  START LEFT RIGHT NONASSOC LESS GREATER COLON PREC SEMI EOF ERROR
%token <string> TYPE
%token <string option> TOKEN
%start spec
%left BAR

%%      

spec:
    | headerOpt decls PERCENT_PERCENT rules EOF { { Header = $1; Decls = List.rev $2; Rules = List.rev $4 } }

headerOpt:
    | HEADER { $1 } 
    |        { "" }

decls:
    | decls decl { $2 :: $1 }
    |            { [] }

decl:
    | TOKEN idents    { Token ($1, List.rev $2) }
    | TYPE idents     { Type ($1, List.rev $2) }
    | START idents    { Start (List.rev $2) }
    | LEFT idents     { Prec (LeftAssoc, List.rev $2) }
    | RIGHT idents    { Prec (RightAssoc, List.rev $2) }
    | NONASSOC idents { Prec (NonAssoc, List.rev $2) }

idents:
    | idents IDENT { $2 :: $1 }
    |              { [] }

rules:
    | rules rule { $2 :: $1 }
    | rule       { [$1] }

rule:
    | IDENT COLON optbar clauses optsemi { ($1, List.rev $4) }

optbar:
    | BAR { }
    |     { }

optsemi:
    | SEMI { }
    |      { }

clauses:
    | clauses BAR clause { $3 :: $1 }
    | clause             { [$1] }

clause:
    | syms optprec CODE { Rule ($1, $2, Some $3) }

syms:
    | IDENT syms { $1 :: $2 }
    | ERROR syms { "error" :: $2 }
    | { [] }

optprec:
    | PREC IDENT { Some $2 }
    |            { None }