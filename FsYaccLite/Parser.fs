// Implementation file for parser generated by fsyacc
module Parser
#nowarn "64"

open Syntax

type token = 
  | IDENT of string
  | TYPE_LITERAL of string
  | HEADER of string
  | CODE of string
  | BAR
  | PERCENT_PERCENT
  | START
  | KW_TYPE
  | TOKEN
  | LEFT
  | RIGHT
  | NONASSOC
  | COLON
  | PREC
  | SEMI
  | EOF

let tagOfToken (t : token) = 
  match t with
  | IDENT _ -> 0 
  | TYPE_LITERAL _ -> 1 
  | HEADER _ -> 2 
  | CODE _ -> 3 
  | BAR  -> 4 
  | PERCENT_PERCENT  -> 5 
  | START  -> 6 
  | KW_TYPE  -> 7 
  | TOKEN  -> 8 
  | LEFT  -> 9 
  | RIGHT  -> 10 
  | NONASSOC  -> 11 
  | COLON  -> 12 
  | PREC  -> 13 
  | SEMI  -> 14 
  | EOF  -> 15 

let endOfInputTag = 18 

let dataOfToken (t : token) : obj = 
  match t with 
  | IDENT x -> box x 
  | TYPE_LITERAL x -> box x 
  | HEADER x -> box x 
  | CODE x -> box x 
  | BAR  -> null 
  | PERCENT_PERCENT  -> null 
  | START  -> null 
  | KW_TYPE  -> null 
  | TOKEN  -> null 
  | LEFT  -> null 
  | RIGHT  -> null 
  | NONASSOC  -> null 
  | COLON  -> null 
  | PREC  -> null 
  | SEMI  -> null 
  | EOF  -> null 

let reductionSymbolCounts = [|1us; 5us; 1us; 0us; 2us; 0us; 1us; 0us; 3us; 3us; 2us; 2us; 2us; 2us; 2us; 0us; 2us; 1us; 6us; 1us; 0us; 1us; 0us; 3us; 1us; 3us; 2us; 0us; 2us; 0us|]
let productionToNonTerminalTable = [|0us; 1us; 2us; 2us; 3us; 3us; 4us; 4us; 5us; 5us; 5us; 5us; 5us; 5us; 6us; 6us; 7us; 7us; 8us; 9us; 9us; 10us; 10us; 11us; 11us; 12us; 13us; 13us; 14us; 14us|]
let maxProductionBodyLength = 6
let actionTable_buckets = [| -1s; -1s; 0s; 1s; 2s; 3s; 4s; 6s; 7s; 9s; 10s; 11s; -1s; 12s; -1s; -1s; -1s; -1s; -1s; 13s; -1s; 14s; 15s; 16s; -1s; 17s; 18s; 19s; 21s; 22s; 23s; 25s; 27s; -1s; -1s; -1s; -1s; -1s; -1s; -1s; 28s; -1s; 30s; -1s; -1s; 31s; 32s; 33s; 34s; 36s; 37s; 38s; -1s; -1s; -1s; -1s; 40s; -1s; -1s; 42s; -1s; 43s; 45s; 46s; 47s; 49s; 52s; 55s; 58s; 62s; 64s; 66s; 67s; -1s; -1s; -1s; -1s; -1s; 68s; -1s; -1s; 70s; 71s; 72s; 74s; 77s; 79s; 81s; 84s; 85s; -1s; -1s; -1s; -1s; -1s; 86s; -1s; 87s; -1s; 88s; -1s; -1s; -1s; 89s; 90s; 91s; 93s; 94s; 96s; 97s; 98s; -1s; -1s; -1s; 99s; -1s; -1s; 100s; 102s; 104s; 105s; 107s; 108s; 109s; 110s; 111s; -1s; 112s; 113s; -1s; -1s |]
let actionTable_entries = [| 2s; 1s; 134s; 17s; 266s; 13s; 5s; -4s; -7s; -4s; 399s; 26s; 7s; -4s; -9s; -4s; 532s; 26s; 9s; -4s; 10s; -4s; 11s; -4s; 668s; -30s; 281s; 24s; 152s; -8s; 153s; 18s; 678s; 40s; 418s; 26s; 157s; -8s; -159s; -8s; 551s; -21s; 159s; -8s; 160s; -8s; -162s; -8s; 554s; -21s; -163s; -8s; 555s; 30s; 163s; -8s; -172s; -16s; 564s; -21s; 304s; 26s; 176s; -16s; 177s; -16s; 178s; -16s; -180s; -16s; 703s; 32s; 180s; -16s; 181s; -16s; -183s; -16s; 706s; -28s; -57s; 32767s; 449s; 29s; 190s; -16s; -324s; -16s; 716s; -28s; 62s; -6s; 63s; -6s; -65s; -6s; 195s; -16s; -66s; -6s; -197s; -16s; 589s; 32s; -67s; -6s; -198s; -16s; 328s; -16s; -68s; -6s; -199s; -16s; 329s; -16s; -69s; -6s; -200s; -16s; -331s; -16s; 592s; -28s; -201s; -16s; 331s; -16s; -202s; -16s; 332s; -16s; 333s; -16s; 334s; -16s; -210s; -16s; 602s; -28s; 81s; 5s; 82s; 6s; -84s; 7s; 214s; -16s; -85s; 8s; -216s; -16s; 608s; 32s; -86s; 9s; 216s; -16s; -87s; 10s; 217s; -16s; -88s; 11s; -219s; -16s; 611s; -28s; 219s; -16s; 220s; -16s; 95s; 13s; 621s; -28s; 361s; -16s; 627s; -23s; 366s; -16s; -368s; -16s; 760s; 43s; 368s; -16s; -370s; -16s; 631s; 37s; 370s; -16s; 371s; -16s; 372s; -16s; 114s; -16s; -249s; 18s; 641s; 38s; -381s; 26s; 642s; -23s; 119s; -16s; -121s; -16s; 513s; 26s; 121s; -16s; 122s; -16s; 123s; -16s; 124s; -16s; 125s; -16s; 782s; 44s; 259s; -8s |]
let actionTable_defaultActions = [| -32768s; -3s; -1s; -32768s; -32768s; -32768s; -32768s; -32768s; -32768s; -32768s; -32768s; -32768s; -5s; -32768s; -32768s; -18s; -11s; -32768s; -7s; -32768s; -12s; -13s; -14s; -32768s; -2s; -17s; -15s; -10s; -9s; -32768s; -20s; -32768s; -32768s; -32768s; -25s; -32768s; -27s; -32768s; -22s; -19s; -32768s; -32768s; -24s; -29s; -26s |]
let gotoTable_buckets = [| 0s; 2s; 4s; -1s; -1s; -1s; -1s; 5s; 6s; 7s; -1s; 9s; 10s; 12s; 13s; 14s; 15s; 16s; -1s; 18s; -1s; -1s; -1s; -1s; 19s; 20s; 23s; -1s; -1s |]
let gotoTable_entries = [| -262s; 27s; 493s; 36s; -2s; 2s; 291s; 28s; 2s; 3s; 65s; 12s; 124s; 19s; -97s; 16s; 444s; 31s; 156s; 21s; -477s; 33s; 505s; 39s; 477s; 34s; 478s; 35s; 218s; 25s; 567s; 42s; -540s; 41s; 568s; 35s; 48s; 4s; 82s; 14s; -84s; 15s; -142s; 20s; 199s; 23s; 171s; 22s |]
let reductions (i : int) (parseState : FsLexYaccLiteRuntime.IParseState) =
    match i with
    | 0 ->
        let _1 = unbox<Syntax.ParserSpec> (parseState.GetInput(1))
        let res =
            failwith "unreachable"
        box<Syntax.ParserSpec> res
    | 1 ->
        let _1 = unbox<'headerOpt> (parseState.GetInput(1))
        let _2 = unbox<'decls> (parseState.GetInput(2))
        let _4 = unbox<'rules> (parseState.GetInput(4))
        let res =
            { Header = _1; Decls = List.rev _2; Rules = List.rev _4 } 
        box<Syntax.ParserSpec> res
    | 2 ->
        let _1 = unbox<string> (parseState.GetInput(1))
        let res =
            _1 
        box<'headerOpt> res
    | 3 ->
        let res =
            "" 
        box<'headerOpt> res
    | 4 ->
        let _1 = unbox<'decls> (parseState.GetInput(1))
        let _2 = unbox<'decl> (parseState.GetInput(2))
        let res =
            _2 :: _1 
        box<'decls> res
    | 5 ->
        let res =
            [] 
        box<'decls> res
    | 6 ->
        let _1 = unbox<string> (parseState.GetInput(1))
        let res =
            Some _1 
        box<'optTypeLiteral> res
    | 7 ->
        let res =
            None 
        box<'optTypeLiteral> res
    | 8 ->
        let _2 = unbox<'optTypeLiteral> (parseState.GetInput(2))
        let _3 = unbox<'idents> (parseState.GetInput(3))
        let res =
            Token (_2, List.rev _3) 
        box<'decl> res
    | 9 ->
        let _2 = unbox<string> (parseState.GetInput(2))
        let _3 = unbox<'idents> (parseState.GetInput(3))
        let res =
            Type (_2, List.rev _3) 
        box<'decl> res
    | 10 ->
        let _2 = unbox<'idents> (parseState.GetInput(2))
        let res =
            Start (List.rev _2) 
        box<'decl> res
    | 11 ->
        let _2 = unbox<'idents> (parseState.GetInput(2))
        let res =
            Prec (LeftAssoc, List.rev _2) 
        box<'decl> res
    | 12 ->
        let _2 = unbox<'idents> (parseState.GetInput(2))
        let res =
            Prec (RightAssoc, List.rev _2) 
        box<'decl> res
    | 13 ->
        let _2 = unbox<'idents> (parseState.GetInput(2))
        let res =
            Prec (NonAssoc, List.rev _2) 
        box<'decl> res
    | 14 ->
        let _1 = unbox<'idents> (parseState.GetInput(1))
        let _2 = unbox<string> (parseState.GetInput(2))
        let res =
            _2 :: _1 
        box<'idents> res
    | 15 ->
        let res =
            [] 
        box<'idents> res
    | 16 ->
        let _1 = unbox<'rules> (parseState.GetInput(1))
        let _2 = unbox<'rule> (parseState.GetInput(2))
        let res =
            _2 :: _1 
        box<'rules> res
    | 17 ->
        let _1 = unbox<'rule> (parseState.GetInput(1))
        let res =
            [_1] 
        box<'rules> res
    | 18 ->
        let _1 = unbox<string> (parseState.GetInput(1))
        let _2 = unbox<'optTypeLiteral> (parseState.GetInput(2))
        let _4 = unbox<'optbar> (parseState.GetInput(4))
        let _5 = unbox<'clauses> (parseState.GetInput(5))
        let _6 = unbox<'optsemi> (parseState.GetInput(6))
        let res =
            { Ident = _1; Type = _2; Clauses = List.rev _5 } 
        box<'rule> res
    | 19 ->
        let res =
            ()
        box<'optbar> res
    | 20 ->
        let res =
            ()
        box<'optbar> res
    | 21 ->
        let res =
            ()
        box<'optsemi> res
    | 22 ->
        let res =
            ()
        box<'optsemi> res
    | 23 ->
        let _1 = unbox<'clauses> (parseState.GetInput(1))
        let _3 = unbox<'clause> (parseState.GetInput(3))
        let res =
            _3 :: _1 
        box<'clauses> res
    | 24 ->
        let _1 = unbox<'clause> (parseState.GetInput(1))
        let res =
            [_1] 
        box<'clauses> res
    | 25 ->
        let _1 = unbox<'syms> (parseState.GetInput(1))
        let _2 = unbox<'optprec> (parseState.GetInput(2))
        let _3 = unbox<string> (parseState.GetInput(3))
        let res =
            { Symbols = _1; PrecSymbol = _2; Code = _3} 
        box<'clause> res
    | 26 ->
        let _1 = unbox<string> (parseState.GetInput(1))
        let _2 = unbox<'syms> (parseState.GetInput(2))
        let res =
            _1 :: _2 
        box<'syms> res
    | 27 ->
        let res =
            [] 
        box<'syms> res
    | 28 ->
        let _2 = unbox<string> (parseState.GetInput(2))
        let res =
            Some _2 
        box<'optprec> res
    | 29 ->
        let res =
            None 
        box<'optprec> res
    | _ -> failwith "unreachable"
let terminalsCount = 19
let nonTerminalsCount = 15
let tables = FsLexYaccLiteRuntime.ParseTables(reductions, endOfInputTag, tagOfToken, dataOfToken, reductionSymbolCounts, productionToNonTerminalTable, maxProductionBodyLength, gotoTable_buckets, gotoTable_entries, nonTerminalsCount, actionTable_buckets, actionTable_entries, actionTable_defaultActions, terminalsCount)
let spec lexer lexbuf = unbox<Syntax.ParserSpec> (tables.Interpret(lexer, lexbuf, 0))
